本文是数据结构与算法系列的第6篇

### 队列基本概念
先进者先出，这就是典型的“队列”。生活中的排队就是一种队列。

还记得吗？栈只支持两个基本操作：入栈 push()和出栈 pop()。

队列最基本的操作也是两个：入队 enqueue()，在队尾插入元素；出队 dequeue()，在队头取出元素。

队列也是一种操作受限的线性表数据结构。

队列的扩展，比如循环队列、阻塞队列、并发队列等在很多偏底层系统、框架、中间件的开发中，起着关键性的作用。

比如高性能队列 Disruptor、Linux 环形缓存，都用到了循环并发队列；Java concurrent 并发包利用 ArrayBlockingQueue 来实现公平锁等。

### 顺序队列和链式队列

队列可以用数组或链表实现。用数组实现的队列叫做顺序队列，用链表实现的队列叫做链式队列。

```
// 用数组实现的队列
public class ArrayQueue {
  // 数组：items，数组大小：n
  private String[] items;
  private int n = 0;
  // head 表示队头下标，tail 表示队尾下标
  private int head = 0;
  private int tail = 0;
  // 申请一个大小为 capacity 的数组
  public ArrayQueue(int capacity) {
    items = new String[capacity];
    n = capacity;
  }
  // 入队
  public boolean enqueue(String item) {
    // 如果 tail == n 表示队列已经满了
    if (tail == n) return false;
    items[tail] = item;
    ++tail;
    return true;
  }
  // 出队
  public String dequeue() {
    // 如果 head == tail 表示队列为空
    if (head == tail) return null;
    // 为了让其他语言的同学看的更加明确，把 -- 操作放到单独一行来写了
    String ret = items[head];
    ++head;
    return ret;
  }
}
```

对于栈的数组实现来说，我们只需要一个栈顶指针就可以了，因为不管插入还是删除都只涉及一端。但是队列有队头和队尾，因此也需要两个指针：一个是 head 指针，指向队头；一个是 tail 指针，指向队尾。需要注意的是，head指针指向队列中的第一个元素，但是tail指针却不是指向队列的最后一个元素，而是指向最后一个元素后面的第一个位置。

由于出队和入队操作会使得head指针和tail指针持续地往后移。

**当 tail 移动到最右边，即使数组中还有空闲空间，也无法继续往队列中添加数据了。这个问题该如何解决呢？**

如果没有空闲空间了，我们只需要在入队时，再集中触发一次数据的搬移操作。借助这个思想，出队函数 dequeue() 保持不变，我们稍加改造一下入队函数 enqueue() 的实现，就可以轻松解决刚才的问题了。

```
// 入队操作，将 item 放入队尾
  public boolean enqueue(String item) {
    // tail == n 表示队列末尾没有空间了
    if (tail == n) {
      // tail ==n && head==0，表示整个队列都占满了
      if (head == 0) return false;
      // 数据搬移
      for (int i = head; i < tail; ++i) {
        items[i-head] = items[i];
      }
      // 搬移完之后重新更新 head 和 tail
      tail -= head;
      head = 0;
    }
    
    items[tail] = item;
    ++tail;
    return true;
  }
```



基于链表的队列实现方法

基于链表的实现，我们同样需要两个指针：head 指针和 tail 指针。它们分别指向链表的第一个结点和最后一个结点。入队时，tail->next= new_node, tail = tail->next；出队时，head = head->next。

代码见[Github](https://github.com/wangzheng0822/algo)

### 循环队列

循环队列长得像一个环，它可以避免数据搬移的操作，但是代码实现难度比非循环队列难多了，**最关键的是，确定好队空和队满的判定条件。**

在用数组实现的非循环队列中，队满的判断条件是tail\==n，队空的判断条件是head\==tail。

针对循环队列，队列为空的判断条件仍然是head\==tail。队满的判断条件是(tail+1)%n==head.

当队列满时，tail指向的位置实际上没有存储数据，循环队列会浪费一个数组的存储空间。



```
public class CircularQueue {
  // 数组：items，数组大小：n
  private String[] items;
  private int n = 0;
  // head 表示队头下标，tail 表示队尾下标
  private int head = 0;
  private int tail = 0;
  // 申请一个大小为 capacity 的数组
  public CircularQueue(int capacity) {
    items = new String[capacity];
    n = capacity;
  }
  // 入队
  public boolean enqueue(String item) {
    // 队列满了
    if ((tail + 1) % n == head) return false;
    items[tail] = item;
    tail = (tail + 1) % n;
    return true;
  }
  // 出队
  public String dequeue() {
    // 如果 head == tail 表示队列为空
    if (head == tail) return null;
    String ret = items[head];
    head = (head + 1) % n;
    return ret;
  }
}
```

### 阻塞队列和并发队列

阻塞队列其实就是在队列基础上增加了阻塞操作。

简单来说，就是

- 在队列为空的时候，从队头取数据会被阻塞，直到队列中有了数据才能返回；
- 队列已满的时候，插入数据会被阻塞，直到队列中有空闲位置后再插入数据，然后再返回。

实际上，这就是个"生产者-消费者模型"。

我们可以使用阻塞队列，轻松实现一个“生产者 - 消费者模型”，可以有效地协调生产和消费的速度。当“生产者”生产数据的速度过快，“消费者”来不及消费时，存储数据的队列很快就会满了。这个时候，生产者就阻塞等待，直到“消费者”消费了数据，“生产者”才会被唤醒继续“生产”。

基于阻塞队列，我们还可以通过协调“生产者”和“消费者”的个数，来提高数据的处理效率。比如我们可以多配置几个“消费者”，来应对一个“生产者”。

**在多线程情况下，会有多个线程同时操作队列，这个时候就会存在线程安全问题，那如何实现一个线程安全的队列呢？**

线程安全的队列我们叫作并发队列。最简单直接的实现方式是直接在 enqueue()、dequeue() 方法上加锁，但是锁粒度大并发度会比较低，同一时刻仅允许一个存或者取操作。实际上，基于数组的循环队列，利用 CAS 原子操作，可以实现非常高效的并发队列。这也是循环队列比链式队列应用更加广泛的原因。

### 队列在线程池等有限资源池中的应用

我们知道，CPU 资源是有限的，任务的处理速度与线程个数并不是线性正相关。过多的线程会导致 CPU 频繁切换，处理性能下降。所以，线程池的大小一般都是综合考虑要处理任务的特点和硬件环境，来事先设置的。

**当我们向固定大小的线程池中请求一个线程时，如果线程池中没有空闲资源了，这个时候线程池如何处理这个请求？是拒绝请求还是排队请求？各种处理策略又是怎么实现的呢？**

一般有两种处理策略。第一种是非阻塞的处理方式，直接拒绝任务请求；另一种是阻塞的处理方式，将请求排队，等到有空闲线程时，取出排队的请求继续处理。那如何存储排队的请求呢？

为了公平地处理每个排队的请求，使用队列来存储排队请求是非常合适的。队列有基于链表和基于数组这两种实现方式。这两种实现方式对于排队请求又有什么区别呢？

**基于链表的实现方式**
- 支持无限排队的无界队列（unbounded queue）
- 可能会导致过多的请求排队等待，请求处理的响应时间过长
- 针对响应时间比较敏感的系统，不适合采用。

**基于数组的实现方式**
- 队列的大小有限的有界队列（bounded queue）
- 线程池中排队的请求超过队列大小时，接下来的请求就会被拒绝
- 对响应时间敏感的系统来说，相对更加合理
- 需要设置一个合理的队列大小。队列太大导致等待的请求太多，队列太小会导致无法充分利用系统资源、发挥最大性能。

除了前面讲到队列应用在线程池请求排队的场景之外，队列可以应用在任何有限资源池中，用于排队请求，比如数据库连接池等。**实际上，对于大部分资源有限的场景，当没有空闲资源时，基本上都可以通过"队列"这种数据结构来实现请求排队。**

### 课后思考

除了线程池这种池结构会用到队列排队请求，你还知道有哪些类似的池结构或者场景中会用到队列的排队请求呢？

分布式应用中的消息队列，也是一种队列结构



今天讲到并发队列，关于如何实现无锁并发队列，网上有非常多的讨论。对这个问题，你怎么看呢？

考虑使用CAS实现无锁队列，则在入队前，获取tail位置，入队时比较tail是否发生变化，如果否，则允许入队，反之，本次入队失败。出队则是获取head位置，进行cas。

### 参考资料：

极客时间专栏《数据结构与算法之美》

