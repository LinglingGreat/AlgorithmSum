

### 一、复杂度分析

**目的**

- 评估算法的执行效率（粗略地说就是算法代码执行的时间），不受测试环境和数据规模的影响。

**大O复杂度表示法(渐进时间复杂度)**

- 所有代码的执行时间T(n)与每行代码的执行次数n成正比，T(n)=O(f(n))，其中f(n)表示每行代码执行的次数总和。
- 大O时间复杂度表示代码执行时间随数据规模增长的变化趋势。

**时间复杂度分析**

- 只关注循环执行次数最多的一段代码；
- 加法法则：总复杂度等于量级最大的那段代码的复杂度；
- 乘法法则：嵌套代码的复杂度等于嵌套内外代码复杂度的乘积

**常见时间复杂度**

- 常量阶O(1)——多项式量级
- 对数阶O(logn)——多项式量级
- 线性阶O(n)——多项式量级
- 线性对数阶O(nlogn)——多项式量级
- 平方阶O(n^2)，立方阶O(n^3)，...k次方阶O(n^k)——多项式量级
- 指数阶O(2^n)——非多项式量级
- 阶乘阶O(n!)——非多项式量级

时间复杂度为非多项式量级的算法问题叫做NP问题。

**空间复杂度(渐进空间复杂度)分析**

- 表示算法的存储空间与数据规模之间的增长关系
- 常见的是O(1)、O(n)、O(n^2)等。

**时间复杂度**

- 最好

- 最坏

- 平均(需要考虑每种情况的概率，可简单假设)

- 均摊
  - 摊还分析法
  - 大部分情况下时间复杂度很低
  - 操作之间存在前后连贯的时序关系
  - 一般等于最好情况时间复杂度

### 二、数组

**数组是一种线性表数据结构**

- 线性表，每个线性表上的数据最多只有前后两个方向
- 连续的内存空间和相同类型的数据

**根据下标随机访问数组元素**

- 寻址公式：a[i]_address = base_address + i * data_type_size
- 查找的时间复杂度不为O(1)，根据下标随机访问的时间复杂度为O(1)

**低效的插入和删除**

- 在开头插入需要搬移数据，时间复杂度为O(n)
- 某些场景下(存储的数据没有规律)，插入时可以只搬移插入位置的数据到末尾，
- 某些场景下(不追求数据的连续性)，删除时可以先记录，等数据没有存储空间时再一并真正地删除
- JVM标记清除垃圾回收算法的核心思想

**警惕数组的访问越界问题**

- 数组越界在C语言中是一种未决行为
- C语言中只要不是访问受限的内存，所有的内存空间都是可以自由访问的
- 访问数组的本质就是访问一段连续内存，数组访问越界时程序可能不会报错
- 很多计算机病毒也正是利用到了代码中的数组越界可以访问非法地址的漏洞，来攻击系统
- Java 会做越界检查

**容器VS数组**

- 对于业务开发，直接使用容器就足够了，省时省力。
- 如果是做一些非常底层的开发，比如开发网络框架，性能的优化需要做到极致，数组就会优于容器。

**数组从 0 开始编号，而不是从 1 开始**

- 计算内存地址时，如果从1开始编号，每次随机访问数组元素都多了一次减法运算，CPU多了一次减法指令
- 历史原因，C语言是从0开始，之后的高级语言效仿C，减少学习成本。

### 三、链表

**单链表**

- 通过指针将一组零散的内存块串联在一起，内存块称为链表的“结点”，记录下个结点地址的指针叫作后继指针 next
- 头结点（记录链表的基地址）
- 尾结点（指向一个空地址NULL）
- 插入和删除的时间复杂度是O(1)
- 随机访问的时间复杂度是O(n)

**循环链表**

- 一种特殊的单链表，尾结点指针指向链表的头结点
- 约瑟夫问题

**双向链表**

- 软件开发中更加常用，如Java的LinkedHashMap容器
- 删除结点中"值等于某个给定值"的结点，单链表和双向链表的时间复杂度都是O(n)
- 删除给定指针指向的结点，单链表O(n)，双向链表O(1)
- 插入操作，双向链表只需要O(1)，单链表需要O(n)。
- 对于有序链表，双向链表的按值查询的效率也要比单链表高一些。我们可以记录上次查找的位置 p，每次查询时进行大小比较
- 用空间换时间的设计思想，缓存也是这种思想

**双向循环链表**

**基于链表实现LRU缓存淘汰算法**

- 先进先出策略 FIFO（First In，First Out）
- 最少使用策略 LFU（Least Frequently Used）
- 最近最少使用策略 LRU（Least Recently Used）
- 维护一个有序单链表，越靠近链表尾部的结点是越早之前访问的。当有一个新的数据被访问时，我们从链表头开始顺序遍历链表。

- - 如果此数据之前已经被缓存在链表中了，我们遍历得到这个数据对应的结点，并将其从原来的位置删除，然后再插入到链表的头部。
  - 如果此数据没有在缓存链表中，又可以分为两种情况：

- - - 如果此时缓存未满，则将此结点直接插入到链表的头部；
    - 如果此时缓存已满，则链表尾结点删除，将新的数据结点插入链表的头部。

**如何轻松写出正确的链表代码**

- 理解指针或引用的含义（存储所指对象的内存地址）
- 警惕指针丢失和内存泄漏（删除和插入时）
- 利用哨兵简化实现难度（head指针一直指向哨兵结点，该结点不存储数据）
- 重点留意边界条件处理
- 举例画图，辅助思考
- 多写多练，没有捷径

### 四、栈

**实现栈**

- 后进者先出，先进者后出
- 用数组实现的栈，我们叫作顺序栈，用链表实现的栈，我们叫作链式栈。
- 两个操作：入栈和出栈，时间复杂度和空间复杂度都是O(1)

**基于数组实现一个可以支持动态扩容的栈**

- 底层依赖一个支持动态扩容的数组
- 入栈空间不足时需要重新申请内存数据搬移
- 时间和空间复杂度仍是O(1)

**栈在函数调用中的作用**

操作系统给每个线程分配了一块独立的内存空间，这块内存被组织成“栈”这种结构, 用来存储函数调用时的临时变量。每进入一个函数，就会将临时变量作为一个栈帧入栈，当被调用函数执行完成，返回之后，将这个函数对应的栈帧出栈。

**栈在表达式求值中的作用**

- 一个保存操作数的栈，另一个是保存运算符的栈。
- 从左向右遍历表达式，数字直接压入操作数栈；运算符，就与运算符栈的栈顶元素进行比较
- 如果比运算符栈顶元素的优先级高，就将当前运算符压入栈；
- 如果比运算符栈顶元素的优先级低或者相同，从运算符栈中取栈顶运算符，从操作数栈的栈顶取 2 个操作数，然后进行计算，再把计算完的结果压入操作数栈，继续比较。

**栈在括号匹配中的作用**

- 检查合法的括号格式
- 用栈来保存未匹配的左括号，从左到右依次扫描字符串。
- 当扫描到左括号时，则将其压入栈中；
- 当扫描到右括号时，从栈顶取出一个左括号。如果能够匹配，则继续扫描剩下的字符串。如果扫描的过程中，遇到不能配对的右括号，或者栈中没有数据，则说明为非法格式。
- 当所有的括号都扫描完成之后，如果栈为空，则说明字符串为合法格式；否则，说明有未匹配的左括号，为非法格式。

**实现浏览器的前进、后退功能**

- 使用两个栈，X 和 Y，把首次浏览的页面依次压入栈 X
- 当点击后退按钮时，再依次从栈 X 中出栈，并将出栈的数据依次放入栈 Y。
- 当我们点击前进按钮时，我们依次从栈 Y 中取出数据，放入栈 X 中。
- 跳转到新的页面需要清空栈Y

### 五、队列

- 先进先出，基本操作是入栈和出栈
- 用数组实现的队列叫做顺序队列，用链表实现的队列叫做链式队列。
- 需要两个指针：一个是 head 指针，指向队头；一个是 tail 指针，指向队尾。
- 入队时，检查tail是否移动到最右边，但数组还有空闲空间，此时集中触发数据搬移操作

**循环队列**

- 最关键的是，确定好队空和队满的判定条件。
- 队列为空的判断条件仍然是head\==tail。队满的判断条件是(tail+1)%n==head.
- 当队列满时，tail指向的位置实际上没有存储数据，循环队列会浪费一个数组的存储空间。

**阻塞队列和并发队列**

- 阻塞队列其实就是在队列基础上增加了阻塞操作。简单来说，就是在队列为空的时候，从队头取数据会被阻塞。如果队列已经满了，那么插入数据的操作就会被阻塞
- "生产者-消费者模型"
- 在多线程情况下，会有多个线程同时操作队列，这个时候就会存在线程安全问题，需要实现一个并发队列
- 基于数组的循环队列，利用 CAS 原子操作，可以实现非常高效的并发队列

**队列在线程池等有限资源池中的应用**

- 非阻塞的处理方式，直接拒绝任务请求；
- 阻塞的处理方式，将请求排队，等到有空闲线程时，取出排队的请求继续处理。用队列来存储排队请求。
  - 基于链表的实现方式，无界队列（unbounded queue），不适合响应时间比较敏感的系统
  - 基于数组实现的有界队列（bounded queue），队列的大小有限，适合响应时间敏感的系统，需要设置一个合理的队列大小

### 参考资料：

极客时间专栏《数据结构与算法之美》
